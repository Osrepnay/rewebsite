<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta property="og:title" content="Text Search and Replace">
        <meta property="og:description" content="Search for and replace specific phrases in a piece of text.">
        <title>Text Search and Replace</title>
        <link rel="stylesheet" href="common.css">
        <style>
            input[type="text"] {
                box-sizing: border-box;
                width: 100%;
                height: 2.5em;
                font-family: monospace;
                font-size: inherit;
                border: 1px solid #aaaaaa;
                border-radius: 3px;
                padding-left: 0.5em;
            }

            textarea {
                white-space: pre;
                outline: 0;
            }

            .wrap {
                white-space: normal;
            }
        </style>
    </head>
    <body>
        
        <h1>Text Search and Replace</h1>
        <p><a href="index.html">&#11172; More Tools</a> &bull; <a href="#" onclick="onClickEmbedLink()">embed page</a></p>
        
        <div>
            <label for="search-phrase">Search for...</label>
            <input type="text" id="search-phrase">
        </div>

        <div>
            <label for="replace-phrase">Replace with...</label>
            <input type="text" id="replace-phrase">
        </div>

        <div>
            <input type="checkbox" id="regex"><label for="regex">regex</label>
            <input type="checkbox" id="case-sensitive"><label for="case-sensitive">case sensitive</label>
            <input type="checkbox" id="linewrap"><label for="linewrap">line wrap</label>
        </div>

        <div style="margin: 0.5em 0;">
            <button id="find-next">find next</button> <button id="replace-next">replace next</button> <button id="replace-all">replace all</button>
        </div>

        <textarea id="in" placeholder="Text goes here...">
            I would think the articles you've read were most likely about the Virtual 8086 Mode introduced with the 386.

Here a host OS (running at privilege 0) would create a standard protected process, but mark it as VM86 when starting. In turn the process will be restricted to real mode addressing (16 bit segment and offset) and a 1 MiB address space.

Despite the naming (8086 mode) the code is not restricted to pure 16 bit. The CPU acts still as 386 enabling use of all operations with 32 bit registers or operands, by applying the usual prefixes. Restrictions comes only due operation encoding (like only BX, BP, SI and DI can be used for addressing) and address calculation. Any offset generated by an address calculation (like base plus index) must be result in a 16 bit value â€” otherwise a protection fault is issued (*1)

Virtual 8086 mode is essentially like the way a 386 comes out of reset, except it provides no way to access an virtual memory functions. All 'real' address generation is restricted to 20 bit, all critical instructions (*2) and I/O (*3) would be trapped, avoiding any break out attempt while allowing the host OS to redirect/emulate all hardware reaction.

In theory it would have been possible to load any arbitrary 16 bit (8086) OS and have it run flawless. For practical reasons higher level abstractions were preferred. After all, a 16 MHz 386 might be fast, but emulating byte wise disk access would it pull well down to C64/1541 level :))

VM86 was introduced with the 80386 and is still available today. Next to all OS adapted to 80386 and later supported this, starting with DR Concurrent DOS and Windows /386 (*4). All Windows supported it for DOS/16 bit programs, as well as OS/2 and Linux (for DOSEMU).

So unlike virtualization that 'multiplies' the existing, 'real' CPU with all its features, VM86 presents a limited CPU model for virtualized tasks.
        </textarea>

        <script src="../scripts/embed.js"></script>
        <script>
            const textarea = document.getElementById("in");
            const searchPhrase = document.getElementById("search-phrase"), replacePhrase = document.getElementById("replace-phrase");
            let regexEnabled = false, caseSensitive = false;

            const regex = (global) => new RegExp(regexEnabled ? searchPhrase.value : searchPhrase.value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), (caseSensitive ? "" : "i") + (global ? "g" : ""));
            const replacement = () => regexEnabled ? replacePhrase.value : replacePhrase.value.replace(/\$/g, "$$$$");

            const scroll = (pos1, pos2) => {
                textarea.selectionStart = pos1;
                textarea.selectionEnd = pos1;
                textarea.blur();
                textarea.focus();
                textarea.selectionEnd = pos2 || pos1;
            };

            const matchNext = () => {

                textarea.focus();

                // check if there's already text highlighted
                if(textarea.selectionStart != textarea.selectionEnd) {
                    scroll(Math.max(textarea.selectionStart, textarea.selectionEnd));
                }

                // reset selection if it's too far
                if(textarea.selectionStart >= textarea.value.length) {
                    scroll(0);
                }

                // match
                return textarea.value.slice(textarea.selectionStart).match(regex());
            
            };

            document.getElementById("find-next").addEventListener("click", (event) => {

                const match = matchNext();
                if(match) {
                    scroll(textarea.selectionStart + match.index, textarea.selectionStart + match.index + match[0].length);
                } else {
                    alert("No match found. Returning to top.");
                    scroll(0);
                }

            });

            document.getElementById("replace-next").addEventListener("click", (event) => {
                
                const match = matchNext();
                if(match) {
                    const replaced = match[0].replace(regex(), replacement());
                    const start = textarea.selectionStart + match.index, end = textarea.selectionStart + match.index + match[0].length;
                    textarea.value = textarea.value.slice(0, start) + replaced + textarea.value.slice(end);
                    scroll(start, start + replaced.length);
                } else {
                    alert("No match found. Returning to top.");
                    scroll(0);
                }

            });

            document.getElementById("replace-all").addEventListener("click", (event) => {
                textarea.value = textarea.value.replace(regex(true), replacement());
            });

            document.getElementById("regex").addEventListener("change", event => regexEnabled = event.target.checked);
            document.getElementById("case-sensitive").addEventListener("change", event => caseSensitive = event.target.checked);
            document.getElementById("linewrap").addEventListener("change", event => event.target.checked ? textarea.classList.add("wrap") : textarea.classList.remove("wrap"));
        </script>

    </body>
</html>